#include <iostream>
#include <string>
#include <bitset>

void StringToBinary(const std::string& s) {
  std::cout << "s=" << s << std::endl;
	std::cout << "s.size=" << s.size() << std::endl;
  for (std::size_t i = 0; i < s.size(); ++i) {
    std::cout << std::bitset<8>(s.c_str()[i]) << " ";
  }
  std::cout << std::endl;
}

int main(int argc, char** argv) {
  std::string str1 =
      "\345\245\207\345\245\207\346\200\252\346\200\252\347\232\204";
  StringToBinary(str1);

  if (argc >= 2) {
    std::string str2 = argv[1];
    StringToBinary(str2);
  }
  return 0;
}


/**

输出:

ubuntu@default:~/project/tempwork/cpp/protobuf/utf8>./a.out "\345\245\207\345\245\207\346\200\252\346\200\252\347\232\204"
s=奇奇怪怪的
s.size=15
11100101 10100101 10000111 11100101 10100101 10000111 11100110 10000000 10101010 11100110 10000000 10101010 11100111 10011010 10000100 
s=\345\245\207\345\245\207\346\200\252\346\200\252\347\232\204
s.size=60
01011100 00110011 00110100 00110101 01011100 00110010 00110100 00110101 01011100 00110010 00110000 00110111 01011100 00110011 00110100 00110101 01011100 00110010 00110100 00110101 01011100 00110010 00110000 00110111 01011100 00110011 00110100 00110110 01011100 00110010 00110000 00110000 01011100 00110010 00110101 00110010 01011100 00110011 00110100 00110110 01011100 00110010 00110000 00110000 01011100 00110010 00110101 00110010 01011100 00110011 00110100 00110111 01011100 00110010 00110011 00110010 01011100 00110010 00110000 00110100 

解释：

1. \ => ASCII = 01011100
   3 => ASCII = 0011 0011
   以此类推

2. 他妈的，代码内部的，和终端的，竟然不一样，今天才搞明白

**/
